// ════════════════════════════════════════════════════════════════════════════
// TrackTx Pipeline Configuration — Universal Auto-Adaptive Setup
// ════════════════════════════════════════════════════════════════════════════
//
// Automatically adapts to any environment (laptop → HPC) with smart defaults
// Resources allocated based on tool efficiency benchmarks
// No manual tuning needed!
//
// Quick Start:
//   Desktop/Mac:    -profile docker
//   Linux:          -profile conda  
//   HPC:            -profile slurm,singularity
//   NFS Issues:     -profile conda_server
//
// ════════════════════════════════════════════════════════════════════════════

nextflow.enable.dsl = 2

// ════════════════════════════════════════════════════════════════════════════
// MANIFEST
// ════════════════════════════════════════════════════════════════════════════

manifest {
  name            = 'tracktx-nf'
  author          = 'Serhat Aktay <serhat.aktay@scilifelab.se>'
  description     = 'Nextflow pipeline for nascent RNA analysis (PRO-seq, GRO-seq)'
  homePage        = 'https://github.com/serhataktay/tracktx-nf'
  version         = '3.0'
  mainScript      = 'main.nf'
  nextflowVersion = '>=24.04.0'
}

// ════════════════════════════════════════════════════════════════════════════
// DEFAULT PARAMETERS
// ════════════════════════════════════════════════════════════════════════════

params {
  // Core Paths (override via params.yaml or command line)
  output_dir    = './results'
  assets_dir    = "${projectDir}/assets"
  genome_cache  = "${projectDir}/.cache/genomes"
  
  // Control Flags
  help          = false
  debug         = false
  debug_report  = false
  force_rebuild = false
  paired_end    = false
  
  // Reporting
  reports_plots = 0
  
  // Divergent Transcription (v3.0)
  advanced = [:]
  
  // Feature Toggles
  fastqc_raw               = true
  counts_allow_index_build = true
  force_sort_bedgraph      = false
  
  // Module-Specific Settings
  adapter_trimming = [:]
  barcode          = [:]
  umi              = [:]
  
  qc = [
    enabled:       true,   // Enable/disable FastQC
    mapq:          10,
    dedup:         true,
    depth_max_cov: 0
  ]
  
  pol2 = [
    contrasts: [],
    top_n:     100,
    plots:     true
  ]
  
  // Conda Environment Overrides
  conda_norm      = null
  conda_pol2      = null
  conda_divergent = null
  conda_fgr       = null
  conda_sra       = null
  
  // GTF Options
  gtf_path = null
  gtf_url  = null
}

// ════════════════════════════════════════════════════════════════════════════
// SYSTEM DETECTION & RESOURCE ALLOCATION HELPERS
// ════════════════════════════════════════════════════════════════════════════

// System Detection
def detectCpus() {
  def cpus = Runtime.runtime.availableProcessors()
  def envCpus = System.getenv('NXF_HOST_CPUS')
  return envCpus ? (envCpus as Integer) : cpus
}

def detectMemoryGb() {
  try {
    def osBean = java.lang.management.ManagementFactory.operatingSystemMXBean
    def method = osBean.class.getMethod('getTotalPhysicalMemorySize')
    long totalBytes = (Long) method.invoke(osBean)
    return Math.max(2, (int)(totalBytes >> 30))
  } catch(Exception e) {
    def envMem = System.getenv('NXF_HOST_MEM')
    return envMem ? (envMem as Integer) : 8
  }
}

def getSystemCpus() { return Math.max(1, detectCpus()) }
def getSystemMemoryGb() { return Math.max(2, detectMemoryGb()) }

// Tool-Specific CPU Allocation (based on efficiency benchmarks)
def alignmentCpus() {
  def total = getSystemCpus()
  if (total <= 4) return total
  if (total <= 8) return 4
  if (total <= 12) return 5
  if (total <= 16) return 6
  if (total <= 32) return 6
  return 8
}

def alignmentForks() {
  def total = getSystemCpus()
  if (total < 8) return 1
  return Math.max(1, (int)(total / alignmentCpus()))
}

def prepareCpus() {
  def total = getSystemCpus()
  if (total <= 4) return Math.max(2, total - 1)
  return 4
}

def prepareForks() {
  def total = getSystemCpus()
  if (total < 6) return 1
  return Math.max(1, (int)(total / prepareCpus()))
}

def tracksCpus() {
  def total = getSystemCpus()
  if (total <= 4) return Math.max(2, total - 1)
  if (total <= 12) return 3
  return 4
}

def tracksForks() {
  def total = getSystemCpus()
  if (total < 6) return 1
  return Math.max(1, (int)(total / tracksCpus()))
}

def normCpus() {
  def total = getSystemCpus()
  if (total <= 4) return total
  if (total <= 8) return 6
  if (total <= 16) return 6
  if (total <= 32) return 8
  return 8
}

def normForks() {
  def total = getSystemCpus()
  if (total < 10) return 1
  return Math.max(1, Math.min(3, (int)(total / normCpus())))
}

def divergentCpus() {
  def total = getSystemCpus()
  if (total <= 4) return total
  if (total <= 8) return 6
  if (total <= 16) return 8
  if (total <= 32) return 8
  return 8
}

def divergentForks() {
  def total = getSystemCpus()
  if (total < 12) return 1
  return Math.max(1, Math.min(3, (int)(total / divergentCpus())))
}

def indexCpus() {
  def total = getSystemCpus()
  if (total <= 4) return total
  if (total <= 8) return 6
  if (total <= 16) return 8
  if (total <= 32) return 12
  return 16
}

def analysisCpus() {
  def total = getSystemCpus()
  if (total <= 4) return 2
  if (total <= 8) return 2
  if (total <= 16) return 3
  return 4
}

def analysisForks() {
  def total = getSystemCpus()
  return Math.max(2, (int)(total / analysisCpus()))
}

def lightweightCpus() { return 1 }
def lightweightForks() { return Math.max(4, (int)(getSystemCpus() / 2)) }

// Memory Allocation Strategies
def intensiveMemory(baseGb = 8) {
  def totalGb = getSystemMemoryGb()
  if (totalGb <= 8) {
    return "${Math.max(4, (int)(totalGb * 0.8))} GB"
  } else if (totalGb <= 32) {
    return "${Math.min((int)(baseGb * 2), (int)(totalGb * 0.5))} GB"
  } else {
    return "${Math.min((int)(baseGb * 3), (int)(totalGb * 0.6))} GB"
  }
}

def moderateMemory(baseGb = 4) {
  def totalGb = getSystemMemoryGb()
  if (totalGb <= 8) {
    return "${Math.max(2, (int)(totalGb * 0.4))} GB"
  } else if (totalGb <= 32) {
    return "${Math.min((int)(baseGb * 1.5), (int)(totalGb * 0.3))} GB"
  } else {
    return "${Math.min((int)(baseGb * 2), (int)(totalGb * 0.4))} GB"
  }
}

def lightMemory() {
  def totalGb = getSystemMemoryGb()
  if (totalGb <= 8) return "1 GB"
  if (totalGb <= 32) return "2 GB"
  return "4 GB"
}

def alignmentMemory() {
  def totalGb = getSystemMemoryGb()
  def forks = alignmentForks()
  if (totalGb <= 8) {
    return "${(int)(totalGb * 0.8)} GB"
  } else if (totalGb <= 32) {
    def perTask = Math.max(8, (int)((totalGb * 0.6) / Math.max(1, forks)))
    return "${Math.min(16, (int)perTask)} GB"
  } else {
    def perTask = Math.max(12, (int)((totalGb * 0.5) / Math.max(1, forks)))
    return "${Math.min(24, (int)perTask)} GB"
  }
}

// ════════════════════════════════════════════════════════════════════════════
// GLOBAL PROCESS DEFAULTS
// ════════════════════════════════════════════════════════════════════════════

ansi { log = true }
log.level = params.debug ? 'debug' : 'info'

process {
  executor  = 'local'
  withConda = true
  scratch   = true
  cleanup   = true
  
  cpus   = { lightweightCpus() }
  memory = { moderateMemory(3) }
  time   = '24h'
  
  errorStrategy = { task.exitStatus in [137,143] ? 'retry' : 'terminate' }
  maxRetries    = 1
  maxErrors     = -1
  
  beforeScript = {
    """
    export OMP_NUM_THREADS=${task.cpus}
    export OPENBLAS_NUM_THREADS=${task.cpus}
    export MKL_NUM_THREADS=${task.cpus}
    export BOWTIE2_THREADS=${task.cpus}
    export SAMTOOLS_THREADS=${task.cpus}
    export BEDTOOLS_THREADS=${task.cpus}
    """
  }
  
  containerOptions = { 
    "--cpus=${task.cpus} --memory=${task.memory.toBytes()} --label nf-task=${task.process.replace(':', '_')}" 
  }
}

// ════════════════════════════════════════════════════════════════════════════
// PROCESS-SPECIFIC RESOURCE ALLOCATION
// ════════════════════════════════════════════════════════════════════════════

process {
  // High-Intensity Processes
  withName: /(?i).*run_alignment.*/ {
    cpus     = { alignmentCpus() }
    memory   = { alignmentMemory() }
    time     = '8h'
    maxForks = alignmentForks()
  }
  
  withName: /(?i).*fetch_and_build_index.*/ {
    cpus     = { indexCpus() }
    memory   = { intensiveMemory(8) }
    time     = '6h'
    maxForks = 1
  }
  
  withName: /(?i).*normalize_tracks.*/ {
    cpus     = { normCpus() }
    memory   = { intensiveMemory(10) }
    time     = '8h'
    maxForks = normForks()
    scratch  = true
  }
  
  withName: /(?i).*detect_divergent_tx.*/ {
    cpus          = { divergentCpus() }
    memory        = { intensiveMemory(10) }
    time          = '8h'
    maxForks      = divergentForks()
    errorStrategy = { task.exitStatus in [137,143] ? 'retry' : 'terminate' }
    maxRetries    = 2
    scratch       = true
  }
  
  // Medium-Intensity Processes
  withName: /(?i).*prepare_input.*/ {
    cpus     = { prepareCpus() }
    memory   = { moderateMemory(5) }
    time     = '4h'
    maxForks = prepareForks()
  }
  
  withName: /(?i).*generate_tracks.*/ {
    cpus     = { tracksCpus() }
    memory   = { moderateMemory(5) }
    time     = '6h'
    maxForks = tracksForks()
  }
  
  withName: /(?i).*calculate_pol2_metrics.*/ {
    cpus     = { analysisCpus() }
    memory   = { moderateMemory(5) }
    time     = '4h'
    maxForks = analysisForks()
  }
  
  withName: /(?i).*call_functional_regions.*/ {
    cpus     = { analysisCpus() }
    memory   = { moderateMemory(4) }
    time     = '4h'
    maxForks = analysisForks()
  }
  
  withName: /(?i)(collect_counts|qc_pol2_tracktx|summarize_pol2_metrics).*/ {
    cpus     = { Math.min(2, Math.max(1, (int)(getSystemCpus() / 4))) }
    memory   = { moderateMemory(3) }
    time     = '2h'
    maxForks = lightweightForks()
  }
  
  // Lightweight Processes
  withName: /(?i).*download_gtf.*/ {
    cpus     = { lightweightCpus() }
    memory   = { lightMemory() }
    time     = '4h'
    maxForks = 1
  }
  
  withName: /(?i).*download_srr.*/ {
    cpus     = { Math.min(4, Math.max(2, (int)(getSystemCpus() / 4))) }
    memory   = { moderateMemory(4) }
    time     = '6h'
    maxForks = Math.max(2, (int)(getSystemCpus() / 4))
  }
  
  withName: /(?i)(generate_reports|combine_reports).*/ {
    cpus     = { lightweightCpus() }
    memory   = { lightMemory() }
    time     = '1h'
    maxForks = lightweightForks()
  }
}

// ════════════════════════════════════════════════════════════════════════════
// EXECUTION REPORTS
// ════════════════════════════════════════════════════════════════════════════

trace {
  enabled   = true
  file      = "${params.output_dir}/trace/trace.txt"
  sep       = '\t'
  fields    = 'task_id,hash,process,tag,cpus,memory,%cpu,%mem,rss,peak_rss,vmem,peak_vmem,realtime,duration,read_bytes,write_bytes,attempt,workdir'
  overwrite = true
}

report {
  enabled   = true
  file      = "${params.output_dir}/trace/report.html"
  overwrite = true
}

timeline {
  enabled   = true
  file      = "${params.output_dir}/trace/timeline.html"
  overwrite = true
}

dag {
  enabled   = true
  file      = "${params.output_dir}/trace/flow_dag.png"
  overwrite = true
}

// ════════════════════════════════════════════════════════════════════════════
// EXECUTION PROFILES
// ════════════════════════════════════════════════════════════════════════════

profiles {
  docker {
    docker.enabled    = true
    docker.autoPull   = true
    process.container = 'ghcr.io/serhataktay/tracktx:latest'
    process.withConda = false
  }
  
  conda {
    process.executor  = 'local'
    conda.enabled     = true
    process.conda     = "${projectDir}/envs/tracktx.yaml"
    process.withConda = true
    
    conda.verbose         = true
    conda.showChannelUrls = true
    conda.useMamba        = false
    conda.cacheDir        = "${ System.getenv('NXF_CONDA_CACHEDIR') ?: projectDir + '/.conda' }"
    conda.createTimeout   = '2h'
    conda.createOptions   = '--no-channel-priority --repodata-fn=repodata.json'
    
    process {
      withConda = true
      env.CONDA_ALWAYS_COPY     = "${ System.getenv('CONDA_ALWAYS_COPY') ?: '1' }"
      env.CONDA_COPY_ALWAYS     = "${ System.getenv('CONDA_COPY_ALWAYS') ?: '1' }"
      env.MAMBA_ALLOW_HARDLINKS = "${ System.getenv('MAMBA_ALLOW_HARDLINKS') ?: '0' }"
      env.MAMBA_ALLOW_SYMLINKS  = "${ System.getenv('MAMBA_ALLOW_SYMLINKS') ?: '0' }"
      env.MAMBA_EXTRACT_THREADS = "${ System.getenv('MAMBA_EXTRACT_THREADS') ?: '1' }"
      env.MAMBA_NO_LOCK         = "${ System.getenv('MAMBA_NO_LOCK') ?: '1' }"
      env.CONDA_SAFETY_CHECKS         = "${ System.getenv('CONDA_SAFETY_CHECKS') ?: 'disabled' }"
      env.CONDA_EXTRA_SAFETY_CHECKS   = "${ System.getenv('CONDA_EXTRA_SAFETY_CHECKS') ?: 'no' }"
      env.CONDA_USE_ONLY_TAR_BZ2      = "${ System.getenv('CONDA_USE_ONLY_TAR_BZ2') ?: '0' }"
      env.CONDA_CHANNEL_PRIORITY      = "${ System.getenv('CONDA_CHANNEL_PRIORITY') ?: 'flexible' }"
      env.CONDA_REMOTE_CONNECT_TIMEOUT_SECS = "${ System.getenv('CONDA_REMOTE_CONNECT_TIMEOUT_SECS') ?: '60' }"
      env.CONDA_REMOTE_READ_TIMEOUT_SECS    = "${ System.getenv('CONDA_REMOTE_READ_TIMEOUT_SECS') ?: '300' }"
      env.CONDA_REMOTE_MAX_RETRIES          = "${ System.getenv('CONDA_REMOTE_MAX_RETRIES') ?: '5' }"
      
      if( System.getenv('CONDA_PKGS_DIRS') ) {
        env.CONDA_PKGS_DIRS = System.getenv('CONDA_PKGS_DIRS')
      }
    }
  }
  
  conda_server {
    process.executor  = 'local'
    conda.enabled     = true
    process.withConda = true
    process.conda     = "${ System.getenv('NXF_CONDA_ENV_PATH') ?: projectDir + '/envs/tracktx.yaml' }"
    
    conda.verbose        = true
    conda.showChannelUrls = true
    conda.useMamba       = false
    conda.useMicromamba  = false
    conda.createTimeout  = '4h'
    conda.createOptions  = '--no-channel-priority --repodata-fn=repodata.json --copy'
    conda.cacheDir       = "${ System.getenv('TMPDIR') ?: '/tmp' }/nextflow-conda-${System.getProperty('user.name')}"
    
    process {
      withConda = true
      env.CONDA_ALWAYS_COPY         = '1'
      env.CONDA_COPY_ALWAYS         = '1'
      env.MAMBA_ALLOW_HARDLINKS     = '0'
      env.MAMBA_ALLOW_SYMLINKS      = '0'
      env.MAMBA_EXTRACT_THREADS     = '1'
      env.MAMBA_NO_LOCK             = '1'
      env.MAMBA_NO_HARDLINKS        = '1'
      env.MAMBA_NO_BANNER           = '1'
      env.CONDA_SAFETY_CHECKS       = 'disabled'
      env.CONDA_EXTRA_SAFETY_CHECKS = 'no'
      env.CONDA_USE_ONLY_TAR_BZ2    = '1'
      env.CONDA_CHANNEL_PRIORITY    = 'disabled'
      env.CONDA_REMOTE_CONNECT_TIMEOUT_SECS = '120'
      env.CONDA_REMOTE_READ_TIMEOUT_SECS    = '600'
      env.CONDA_REMOTE_MAX_RETRIES          = '10'
      env.CONDA_REMOTE_BACKOFF_FACTOR       = '2'
      env.CONDA_PKGS_DIRS     = "${ System.getenv('TMPDIR') ?: '/tmp' }/conda-pkgs-${System.getProperty('user.name')}"
      env.CONDA_SOLVER        = 'classic'
      env.CONDA_EXPERIMENTAL  = 'no'
      env.CONDA_REPODATA_THREADS = '1'
      env.CONDA_FETCH_THREADS    = '1'
    }
    
    beforeScript = '''
      mkdir -p "${CONDA_PKGS_DIRS}" || true
      chmod 755 "${CONDA_PKGS_DIRS}" || true
      find "${CONDA_PKGS_DIRS}" -name "*.lock" -mtime +1 -delete 2>/dev/null || true
      touch "${CONDA_PKGS_DIRS}/.write_test" && rm -f "${CONDA_PKGS_DIRS}/.write_test" || {
        echo "WARNING: Cannot write to ${CONDA_PKGS_DIRS}"
        export CONDA_PKGS_DIRS="/tmp/conda-emergency-${RANDOM}"
        mkdir -p "${CONDA_PKGS_DIRS}"
      }
      _conda_init=false
      if [ -n "${CONDA_EXE}" ] && [ -x "${CONDA_EXE}" ]; then
        eval "$(${CONDA_EXE} shell.bash hook 2>/dev/null)" && _conda_init=true
      fi
      if [ "$_conda_init" = "false" ] && command -v conda >/dev/null 2>&1; then
        eval "$(conda shell.bash hook 2>/dev/null)" && _conda_init=true
      fi
      if [ "$_conda_init" = "false" ]; then
        for conda_sh in \
          "${HOME}/miniconda3/etc/profile.d/conda.sh" \
          "${HOME}/anaconda3/etc/profile.d/conda.sh" \
          "${HOME}/mambaforge/etc/profile.d/conda.sh" \
          "/opt/conda/etc/profile.d/conda.sh"
        do
          [ -f "$conda_sh" ] && source "$conda_sh" && _conda_init=true && break
        done
      fi
      [ "$_conda_init" = "false" ] && echo "WARNING: Conda initialization failed"
    '''
  }
  
  singularity {
    singularity.enabled    = true
    singularity.autoMounts = true
    singularity.cacheDir   = "${baseDir}/.singularity"
    process.container      = 'docker://ghcr.io/serhataktay/tracktx:latest'
    process.withConda      = false
    singularity.runOptions = ['--bind /tmp:/tmp', '--bind /var/tmp:/var/tmp', '--bind /scratch:/scratch', '--cleanenv', '--no-home']
  }
  
  apptainer {
    singularity.enabled    = true
    singularity.autoMounts = true
    singularity.cacheDir   = "${baseDir}/.singularity"
    process.container      = 'docker://ghcr.io/serhataktay/tracktx:latest'
    process.withConda      = false
    singularity.runOptions = ['--bind /tmp:/tmp', '--bind /var/tmp:/var/tmp', '--bind /scratch:/scratch', '--cleanenv', '--no-home']
  }
  
  podman {
    podman.enabled    = true
    podman.autoPull   = true
    process.container = 'ghcr.io/serhataktay/tracktx:latest'
    process.withConda = false
  }
  
  local {
    process.executor  = 'local'
    process.withConda = false
  }
  
  slurm {
    process.executor = 'slurm'
    process.queue    = 'normal'
  }
  
  // Performance optimizations for external storage (USB, NAS, network drives)
  performance {
    process {
      // Disable scratch on external drives (scratch copying is extremely slow)
      scratch = false
      cleanup = true
      
      // Increase parallelism for better throughput on slow I/O
      // Note: These are multipliers on top of the adaptive system
      maxForks = Math.max(12, (int)(getSystemCpus() * 1.5))
    }
    
    // Optimize executor for better scheduling
    executor {
      queueSize = 100
    }
    
    // Docker optimizations
    docker {
      remove = true
    }
  }
}
